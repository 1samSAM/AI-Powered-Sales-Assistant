sentiment_analyzer = pipeline("sentiment-analysis", model="distilbert-base-uncased-finetuned-sst-2-english")
tone_analyzer = pipeline("text-classification", model="j-hartmann/emotion-english-distilroberta-base")



def analyze_sentiment(text):
    try:
        result = sentiment_analyzer(text)[0]
        return result["label"]
    except Exception as e:
        print(f"Error in sentiment analysis: {e}")
        return "UNKNOWN"


# Tone analysis
def analyze_tone(text):
    try:
        result = tone_analyzer(text)[0]
        return result["label"]
    except Exception as e:
        print(f"Error in tone analysis: {e}")
        return "UNKNOWN"


# Transcribe and analyze user audio input
def transcribe_audio():
    global is_listening
    recognizer = sr.Recognizer()

    while is_listening:
        with sr.Microphone() as source:
            print("Listening...")
            try:
                audio_data = recognizer.listen(source, timeout=5)
                print("Recognizing...")
                text = recognizer.recognize_google(audio_data, language="en-US")
                print(f"Transcribed: {text}")

                 # Default values for variables
                sentiment, tone, best_price, guidance = "UNKNOWN", "UNKNOWN", 0.0, ""

        

                
                results.append(
                    {
                        "text": text,
                        "sentiment": sentiment,
                        "tone": tone,
                        "product_name": product[1] if product else "None",
                        "best_price": round(best_price, 2) if best_price else "N/A",
                        "guidance": guidance
                    }
                )
                
            except sr.UnknownValueError:
                print("Could not understand the audio.")
            except sr.WaitTimeoutError:
                print("Listening timed out while waiting for phrase to start.")
            except Exception as e:
                print(f"Error during transcription: {e}")























# Function to simulate AI-powered negotiation coaching with Chain-of-Thought prompting
def negotiation_assistant(customer_name, sentiment, tone, recommendation):
    """
    AI generates negotiation tips and dynamically retrieves car details, pricing, and negotiation logic.
    The LLM autonomously calculates discounts and justifies pricing.
    """
    prompt = f"""
    INSTRUCTIONS:
    -- You are an AI assistant representing the seller in a car negotiation.
    -- The customer '{customer_name}' has shown interest in the following recommendations:
       {recommendation}
    -- Your goal is to handle negotiation autonomously by dynamically retrieving details like price, features, 
       and calculating appropriate discounts.

    OBJECTIVES:
    1. Retrieve key details for each recommended car (name, price, features, and total price).
    2. Define the initial discount as 0% and set a maximum discount of 40%.
    3. Compute the 'max_discounted_price' as 70% of the grand total of the cars.
    4. Use a step-by-step chain of thought to generate a negotiation response:
       a. Present the features and benefits of each car.
       b. Start with a 5% discount and justify the pricing.
       c. Gradually increase the discount by 5% increments only if necessary, up to a maximum of 40%.
    5. Maintain customer satisfaction while ensuring profitability.

    CUSTOMER CONTEXT:
    -- Sentiment: {sentiment}
    -- Tone: {tone}

    RESPONSE FORMAT:
    1. Provide a summary of the car details with calculated prices after applying the current discount.
    2. Justify the pricing using the car features and benefits.
    3. Mention additional offers (e.g., free maintenance, extended warranties) to close the deal.
    4. Provide a concise recommendation to proceed with the deal.
    5.provide the tips to saler how to deal with customer to succesfully complete the deal(2 tips)

    BEGIN CHAIN OF THOUGHT:
    """
    try:
        # Invoke LLM to handle negotiation logic
        response = llm.invoke([HumanMessage(content=prompt)])
        return response.content.strip()
    except Exception as e:
        st.error(f"Error generating negotiation tips: {e}")
        return "Unable to generate tips. Please try again."


# Continuous negotiation logic
def continuous_negotiation(customer_data, customer_query):
    st.subheader(f"Negotiation with {customer_data.get('Name', 'Customer')}")

    # Get the LLM recommendation
    recommendation = customer_data.get("RecommendedDeal", "No recommendations provided.")
    if recommendation == "No recommendations provided.":
        st.error("No car recommendations available for negotiation.")
        return

    negotiation_result = "In Progress"
    sentiment = customer_data.get("Sentiment", "Neutral")
    tone = customer_data.get("Tone", "Neutral")

    while negotiation_result == "In Progress":
        # Generate negotiation tips dynamically
        with st.chat_message("assistant"):
            tips = negotiation_assistant(
                customer_data.get('Name', 'Customer'),
                sentiment,
                tone,
                recommendation
            )
            st.write(tips)

        # Customer's response
        with st.chat_message("user"):
            customer_query = st.text_input("Your response:", key=f"query_step_{recommendation}")
            if not customer_query:
                st.stop()

        # Sentiment and tone analysis (placeholder functions)
        sentiment = analyze_sentiment(customer_query)
        tone = analyze_tone(customer_query)

        # Display assistant message with next negotiation step
        st.chat_message("assistant").write(
            "What would you like to do next? Choose an option below."
        )

        # Handle negotiation closure
        negotiation_result = st.radio(
            "Next Step:",
            ["Continue Negotiation", "Close Deal", "End Negotiation"],
            key=f"negotiation_step_{recommendation}"
        )

        if negotiation_result == "Close Deal":
            st.success("Deal closed successfully! Congratulations!")
            break
        elif negotiation_result == "End Negotiation":
            st.warning("Negotiation ended without a deal.")
            break








def negotiation_assistant(
    customer_name, sentiment, tone, recommendation, current_discount, max_discount, customer_query1, his_negotiation
):
    """
    AI generates concise negotiation tips with relevant car details, pricing, and negotiation logic.
    The LLM calculates discounts and provides seller-focused suggestions to close the deal.
    """
    prompt = f"""
        INSTRUCTIONS:
        -- You are an AI assistant representing the seller in a car negotiation.
        -- The customer '{customer_name}' has shown interest in the following recommendations:
        {recommendation}
        -- Your goal is to dynamically retrieve details like price, features, and calculate appropriate discounts while ensuring continuity with previous discussions.

        OBJECTIVES:
        1. Retrieve key details for each recommended car (name, price, features).
        2. Start with the current discount of {current_discount}% and ensure the maximum discount does not exceed {max_discount}%.
        3. Consider the customer's input: "{customer_query1}" to address specific concerns and preferences.
        4. Use the previous negotiation response: "{his_negotiation}" to ensure continuity and personalized engagement.
        5. Generate a focused response prioritizing customer satisfaction while maintaining profitability.

        CUSTOMER CONTEXT:
        -- Sentiment: {sentiment}
        -- Tone: {tone}
        -- Customer Input: {customer_query1}

        RESPONSE FORMAT:
        1. Key Highlights: Provide a brief summary of the car details with calculated prices after the current discount.
        2. Justification: Offer one or two strong reasons for the pricing based on features, benefits, and offers.
        3. Seller Recommendation: Suggest one actionable next step to secure the deal.
        4. Tips for the Seller: Provide two concise, actionable tips to help close the deal based on the customer's sentiment and tone.

        BEGIN RESPONSE:
    """

    try:
        # Invoke LLM to handle negotiation logic
        response = llm.invoke([HumanMessage(content=prompt)])
        return response.content.strip()
    except Exception as e:
        st.error(f"Error generating negotiation tips: {e}")
        return "Unable to generate tips. Please try again."

if "negotiation_history" not in st.session_state:
    st.session_state.negotiation_history = []
if "key_counter" not in st.session_state:
    st.session_state.key_counter = 0
if "negotiation_active" not in st.session_state:
    st.session_state.negotiation_active = True  # Track if negotiation is ongoing
if "current_step" not in st.session_state:
    st.session_state.current_step = 1  # Start from the first step

def continuous_negotiation(customer_data):
    customer_name = customer_data.get('Name', 'Customer')
    recommendation = customer_data.get("RecommendedDeal", "No recommendations provided.")
    sentiment = customer_data.get("Sentiment", "Neutral")
    tone = customer_data.get("Tone", "Neutral")

    if recommendation == "No recommendations provided.":
        st.error("No car recommendations available for negotiation.")
        return

    current_discount = 5  # Starting discount
    max_discount = 40     # Maximum discount

    # Initial negotiation tips from the assistant
    initial_tips = negotiation_assistant(
        customer_name,
        sentiment,
        tone,
        recommendation,
        current_discount,
        max_discount,
        customer_query1="No previous query",
        his_negotiation="No previous negotiation history."
    )
    st.write(initial_tips)
    st.session_state.negotiation_history.append(initial_tips)

    # Display negotiation options
    unique_key = f"negotiation_step_{st.session_state.key_counter}"
    negotiation_result = st.radio(
        "Next Step:",
        ["Continue Negotiation", "Close Deal", "End Negotiation"],
        key="negotiation_result"
    )

    if negotiation_result == "Close Deal":
        st.success("Deal closed successfully! Congratulations!")
        st.session_state.negotiation_active = False

    elif negotiation_result == "End Negotiation":
        st.warning("Negotiation ended without a deal.")
        st.session_state.negotiation_active = False

    elif negotiation_result == "Continue Negotiation":
        # Customer input for further negotiation
        customer_query1 = st.text_input(
            "Enter customer's query or response:",
            key=f"{unique_key}_query"
        )

        if customer_query1:  # Proceed if input is provided
            sentiment = analyze_sentiment(customer_query1)
            tone = analyze_tone(customer_query1)

            # Generate updated negotiation tips
            tips = negotiation_assistant(
                customer_name=customer_name,
                sentiment=sentiment,
                tone=tone,
                recommendation=recommendation,
                current_discount=current_discount,
                max_discount=max_discount,
                customer_query1=customer_query1,
                his_negotiation=st.session_state.negotiation_history[-1] if st.session_state.negotiation_history else ""
            )
            st.session_state.negotiation_history.append(tips)
            st.write(tips)

            # Adjust discount based on input
            if "discount" in customer_query1.lower() and current_discount < max_discount:
                current_discount += 5
                st.info(f"Discount increased to {current_discount}%.")
            elif current_discount >= max_discount:
                st.warning("Maximum discount of 40% has been reached.")

    # Display negotiation history after ending or closing
    if not st.session_state.negotiation_active:
        st.info("Negotiation process completed.")
        if st.session_state.negotiation_history:
            st.write("Negotiation History:")
            for idx, step in enumerate(st.session_state.negotiation_history, 1):
                st.write(f"{idx}. {step}")




















def handle_input(customer_data):
    if 'current_discount' not in st.session_state:
        st.session_state.current_discount = 5 
    # Extract customer details
    customer_id = customer_data['CustomerID']
    customer_name = customer_data.get('Name', 'Customer')
    recommendation = customer_data.get("RecommendedDeal", "No recommendations provided.")
    sentiment = customer_data.get("Sentiment", "Neutral")
    tone = customer_data.get("Tone", "Neutral")

    # Initialize negotiation history and conversation history for the specific customer
    if f'negotiation_history_{customer_id}' not in st.session_state:
        st.session_state[f'negotiation_history_{customer_id}'] = []
    
    if f'conversation_{customer_id}' not in st.session_state:
        st.session_state[f'conversation_{customer_id}'] = []

    # Check if this is the first interaction
    if not st.session_state[f'negotiation_history_{customer_id}']:
        # Initial negotiation tips from the assistant
        initial_tips = negotiation_assistant(
            customer_name,
            sentiment,
            tone,
            recommendation,
            current_discount=st.session_state.current_discount,
            max_discount=40,
            customer_query1="No previous query",
            his_negotiation="No previous negotiation history."
        )
        st.write(initial_tips)
        st.session_state[f'negotiation_history_{customer_id}'].append(initial_tips)

    # Get user input
    user_input = st.session_state.user_query
    if user_input:
        # Append user input to the conversation history
        st.session_state[f'conversation_{customer_id}'].append(f"### You: {user_input}")

        # Analyze sentiment and tone of the user input
        sentiment = analyze_sentiment(user_input)
        tone = analyze_tone(user_input)

        # Generate updated negotiation tips
        tips = negotiation_assistant(
            customer_name=customer_name,
            sentiment=sentiment,
            tone=tone,
            recommendation=recommendation,
            current_discount=st.session_state.current_discount,
            max_discount=40,  # Maximum discount
            customer_query1=user_input,
            his_negotiation=st.session_state[f'negotiation_history_{customer_id}'][-1] if st.session_state[f'negotiation_history_{customer_id}'] else ""
        )

        # Append the bot's response to the conversation and negotiation history
        st.session_state[f'conversation_{customer_id}'].append(f"### Bot: {tips}")
        st.session_state[f'negotiation_history_{customer_id}'].append(tips)
        st.session_state.user_query = ""  # Clear input after submission
    
    # Display the conversation history for the specific customer
    #for message in st.session_state[f'conversation_{customer_id}']:
    #    st.write(message)